use super::*;

// This LR(1) grammar has been written to bootstrap our peg parser generator. This peg definition
// parser has the following limitations:
//
// - No comments are allowed. This would require a custom lalrpop lexer, which is not worth
//   the trouble. We can bootstrap this to create a peg grammar parser
// - Definitions must be terminated with a ";". This is to make the grammar LR(1)

grammar;

pub PEG: Vec<Definition> = {
    Definition+ => <>,
}

Definition: Definition = {
    <id:Identifier> "<-" <def:SequenceAlternative> ";" => {
        Definition {
            id,
            def,
        }
    }
}

SequenceAlternative: Expression = {
    <l:SequenceNoAlternative> "/" <r:SequenceAlternative> => {
        Expression::Alternative(Box::new(l), Box::new(r))
    },
    SequenceNoAlternative,
}

SequenceNoAlternative: Expression = {
    <Sequence+> => {
        if <>.len() == 1 {
            <>[0].clone()
        } else {
            Expression::List(<>)
        }
    }
}

Sequence: Expression = {
    "(" <SequenceAlternative> ")" => <>,
    Primary => <>,
    <Sequence> "?" => Expression::Optional(Box::new(<>)),
    <Sequence> "*" => Expression::Any(Box::new(<>)),
    <Sequence> "+" => Expression::More(Box::new(<>)),
}

Primary: Expression = {
    "&" <Primary> => Expression::MustMatch(Box::new(<>)),
    "!" <Primary> => Expression::MustNotMatch(Box::new(<>)),
    Identifier => Expression::Identifier(<>.into()),
    r#""([^"\\]|\\.)*""# => Expression::StringLiteral(<>.into()),
    r#"'([^'\\]|\\.)*'"# => Expression::StringLiteral(<>.into()),
    "." => Expression::Dot,
    r#"r"([^"\\]|\\.)*""# => Expression::Regex(<>.into()),
}

Identifier: String = {
    r"[_a-zA-Z][a-zA-Z0-9_]*" => <>.into(),
}